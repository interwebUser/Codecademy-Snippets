{\rtf1\ansi\ansicpg1252\cocoartf2511
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Avenir-Heavy;\f1\fnil\fcharset0 Avenir-Book;\f2\fnil\fcharset0 LucidaGrande;
\f3\fnil\fcharset0 Monaco;\f4\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red10\green12\blue22;
\red255\green255\blue255;\red10\green12\blue22;\red56\green56\blue56;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c99985;\cssrgb\c3962\c5536\c11414;
\cssrgb\c100000\c100000\c100000;\cssrgb\c3922\c5490\c11373;\cssrgb\c28235\c28235\c28235;}
{\*\listtable{\list\listtemplateid1\listhybrid{\listlevel\levelnfc23\levelnfcn23\leveljc0\leveljcn0\levelfollow0\levelstartat1\levelspace360\levelindent0{\*\levelmarker \{disc\}}{\leveltext\leveltemplateid1\'01\uc0\u8226 ;}{\levelnumbers;}\fi-360\li720\lin720 }{\listname ;}\listid1}}
{\*\listoverridetable{\listoverride\listid1\listoverridecount0\ls1}}
\margl1440\margr1440\vieww17380\viewh22280\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\b\fs128 \cf2 Why Asymptotic Notation?\

\f1\b0\fs32 \
When writing programs, it\'92s important to make smart programming choices so that code runs most efficiently. Computers seem to take no time evaluating programs, but when scaling programs to deal with massive amounts of data, writing efficient code becomes the difference between success and failure. In computer science, we define how efficient a program is by its runtime.\
We can\'92t just time the program, however, because different computers run at different speeds. My dusty old PC does not run as fast as your brand new laptop. Programming is also done in many different languages, how do we account for that in the runtime? We need a general way to define a program\'92s runtime across these variable factors. We do this with Asymptotic Notation.\
With asymptotic notation, we calculate a program\'92s runtime by looking at how many instructions the computer has to perform based on the size of the program\'92s input. For example, if I were calculating the maximum element in a collection, I would need to examine each element in the collection. That examining step is the same regardless of the language used, or the CPU that\'92s performing the calculation. In asymptotic notation, we define the size of the input as N. I may be looking through a collection of 10 elements, or 100 elements, but we only need to know how many steps are performed relative to the input so N is used in place of a specific number. If there is a second input, we may define the size of that input as M.\
There are varieties of asymptotic notation that focus on different concerns. Some will communicate the best case scenario for a program. For example, if we were searching for a value within a collection, the best case would be if we found that element in the first place we looked. Another type will focus on the worst case scenario, such as if we searched for a value, looked in the entire dataset and did not find it. Typically programmers will focus on the worst case scenario so there is an upper bound of runtime to communicate. It\'92s a way of saying \'93things may get this bad, or slow, but they won\'92t get worse!\'94\
In this next module, we will learn more about asymptotic notation, how to properly analyze the runtime of a program through asymptotic notation, and how to take into consideration the runtime of different data structures and algorithms when creating programs. Learning these skills will change the way you think when you design programs and it will prepare you for the software engineering world where creating efficient programs is an essential skill.\
Let\'92s dive into the world of asymptotic notation!\
\
Program runtime equation example:\
5N^2+3N+5\
=> N^2+N\
=> N^2\
(Essentially take the Limit as N->inf and determine behavior)\
There are three different ways we could describe the runtime of this program: big Theta or 
\f2 \uc0\u920 
\f1 (N2), big O or O(N2), big Omega or \uc0\u937 (N2). \
\

\f0\b\fs48 Notation Variants:\

\f1\b0\fs32 \ul 1. Big Theta (
\f2 \uc0\u920 )
\f1 \ulnone \
We use big Theta when a program has only one case in term of runtime. 
\f2 \uc0\u920 
\f1 ().\
Ex. 1:\
\pard\pardeftab720\partightenfactor0

\f3\fs28\fsmilli14080 \cf3 \cb4 \expnd0\expndtw0\kerning0
\shad\shadx20\shady-20\shadr20\shado0 \shadc0 Function with input that is a list of size N:\
   For each value in list:\
    Print the value\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb1 \kerning1\expnd0\expndtw0 \shad0 The number of instructions the computer has to perform is based on how many iterations the loop will do because if the loop does more iterations, then the computer will perform instructions.\
\
In the following pseudocode program, the function takes in an integer, N, and counts the number of times it takes for N to be divided by 2 until N reaches 1.\
Ex. 2:\
\pard\pardeftab720\partightenfactor0

\f3\fs28\fsmilli14080 \cf5 \cb6 \expnd0\expndtw0\kerning0
\shad\shadx20\shady-20\shadr20\shado0 \shadc0 Function that has integer input N:\
    Set a count variable to 0\
    Loop while N is not equal to 1:\
        Increment count\
        N = N/2\
    Return count\
\pard\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb1 \kerning1\expnd0\expndtw0 \shad0 With an integer N, the loop will iterate log2(N) times. However, because we drop constants in asymptotic notation, we would say that the runtime of this program is 
\f2 \uc0\u920 
\f1 (log N).\
\

\f0\b\fs36 Common Runtimes:
\fs48 \

\f1\b0\fs32 Before we delve into the multiple runtime cases, let\'92s see the different common runtimes a program could have. Below is a list of common runtimes that run from fastest to slowest.\
\pard\tx220\tx720\pardeftab720\li720\fi-720\partightenfactor0
\ls1\ilvl0
\f2 \cf2 {\listtext	\uc0\u8226 	}\uc0\u920 
\f1 (1). This is constant runtime. This is the runtime when a program will always do the same thing regardless of the input. For instance, a program that only prints \'93hello, world\'94 runs in 
\f2 \uc0\u920 
\f1 (1) because the program will always just print \'93hello, world\'94.\
{\listtext	\uc0\u8226 	}
\f2 \uc0\u920 
\f1 (log N). This is logarithmic runtime. You will see this runtime in search algorithms.\
{\listtext	\uc0\u8226 	}
\f2 \uc0\u920 
\f1 (N). This is linear runtime. You will often see this when you have to iterate through an entire dataset.\
{\listtext	\uc0\u8226 	}
\f2 \uc0\u920 
\f1 (N*logN). You will see this runtime in sorting algorithms.\
{\listtext	\uc0\u8226 	}
\f2 \uc0\u920 
\f1 (N^2). This is an example of a polynomial runtime. You will see this runtime when you have to search through a two-dimensional dataset (like a matrix) or nested loops.\
{\listtext	\uc0\u8226 	}
\f2 \uc0\u920 
\f1 (2^N). This is exponential runtime. You will often see this runtime in recursive algorithms (Don\'92t worry if you don\'92t know what that is yet!).\
{\listtext	\uc0\u8226 	}
\f2 \uc0\u920 
\f1 (N!). This is factorial runtime. You will often see this runtime when you have to generate all of the different permutations of something. For instance, a program that generates all the different ways to order the letters \'93abcd\'94 would run in this runtime.\
\pard\tx720\pardeftab720\partightenfactor0
\cf2 \
\ul 2. Big Omega and Big O\
\pard\pardeftab720\partightenfactor0
\cf2 \ulnone Sometimes, a program may have a different runtime for the best case and worst case. For instance, a program could have a best case runtime of 
\f2 \uc0\u920 
\f1 (1) and a worst case of 
\f2 \uc0\u920 
\f1 (N). We use big Omega or \uc0\u937  to describe the best case and big O or O to describe the worst case. Take a look at the following pseudocode that returns True if 12 is in the list and False otherwise:
\f4\fs35\fsmilli17600 \cf7 \expnd0\expndtw0\kerning0
\
\pard\pardeftab720\partightenfactor0

\f3\fs28\fsmilli14080 \cf5 \cb6 \shad\shadx20\shady-20\shadr20\shado0 \shadc0 Function with input that is a list of size N:\
    For each value in the list:\
        If value is equal to 12:\
            Return True\
    Return False\
\pard\tx720\pardeftab720\partightenfactor0

\f1\fs32 \cf2 \cb1 \kerning1\expnd0\expndtw0 \shad0 \
Analyze the function edge cases (best and worst case) to determine how it will perform for \uc0\u937 () and O(), respectively.\
\
}